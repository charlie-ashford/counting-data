<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Communitrics Counting</title>

    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap"
      rel="stylesheet"
    />

    <link rel="icon" href="./image.png" type="image/png" />

    <script src="https://code.highcharts.com/12.0.2/highcharts.js"></script>
    <script src="https://code.highcharts.com/12.0.2/modules/exporting.js"></script>
    <script src="https://code.highcharts.com/12.0.2/modules/export-data.js"></script>
    <script src="https://code.highcharts.com/12.0.2/modules/accessibility.js"></script>
    <script src="https://code.highcharts.com/12.0.2/modules/xrange.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style>
      :root {
        --accent-color: #ed4c67;
        --accent-hover: #db284f;

        --body-gradient-start: #ffffff;
        --body-gradient-end: #f9fafb;
        --card-bg: rgba(255, 255, 255, 0.55);
        --text-color: #1f1f1f;
        --text-muted: #6b7280;
        --border-color: rgba(255, 255, 255, 0.4);

        --glass-blur: blur(16px);
        --card-shadow: 0 8px 16px rgba(0, 0, 0, 0.07);

        --heading-font-weight: 600;
        --body-font-weight: 400;

        --transition-speed: 0.3s;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --body-gradient-start: #1f1f1f;
          --body-gradient-end: #2b2b2b;
          --card-bg: rgba(44, 44, 44, 0.6);
          --text-color: #e5e5e5;
          --text-muted: #a3a3a3;
          --border-color: rgba(255, 255, 255, 0.1);
          --card-shadow: 0 8px 16px rgba(0, 0, 0, 0.45);
        }
      }

      *,
      *::before,
      *::after {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html {
        scroll-behavior: smooth;
      }
      body {
        font-family: "Poppins", sans-serif;
        color: var(--text-color);
        line-height: 1.5;
        background: linear-gradient(
          120deg,
          var(--body-gradient-start) 0%,
          var(--body-gradient-end) 100%
        );
        min-height: 100vh;
      }

      .container {
        width: 95%;
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      .server-info {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      .server-icon {
        width: 64px;
        height: 64px;
        border-radius: 20px;
        box-shadow: var(--card-shadow);
        object-fit: cover;
      }
      .server-info h1 {
        font-weight: var(--heading-font-weight);
        font-size: 1.8rem;
      }

      #exportCsvBtn {
        background: var(--accent-color);
        color: #fff;
        font-weight: var(--heading-font-weight);
        font-size: 0.95rem;
        border: none;
        outline: none;
        border-radius: 12px;
        padding: 12px 26px;
        box-shadow: var(--card-shadow);
        cursor: pointer;
        transition: background-color var(--transition-speed),
          transform var(--transition-speed), box-shadow var(--transition-speed);
      }
      #exportCsvBtn:hover {
        background: var(--accent-hover);
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.12);
      }
      #exportCsvBtn:active {
        transform: scale(0.96);
      }

      .tabs {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 30px;
      }
      .tab {
        flex: 1;
        text-align: center;
        padding: 12px 0;
        background-color: var(--card-bg);
        backdrop-filter: var(--glass-blur);
        border: 1px solid var(--border-color);
        border-radius: 999px;
        cursor: pointer;
        font-weight: var(--heading-font-weight);
        transition: all var(--transition-speed);
        box-shadow: var(--card-shadow);
      }
      .tab.active {
        background: var(--accent-color);
        color: #fff;
        border-color: transparent;
        transform: translateY(-2px);
      }
      .tab:hover {
        transform: translateY(-2px);
      }

      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }

      .card {
        background-color: var(--card-bg);
        backdrop-filter: var(--glass-blur);
        border-radius: 16px;
        padding: 20px;
        box-shadow: var(--card-shadow);
        margin-bottom: 20px;
        transition: transform var(--transition-speed);
      }
      .card:hover {
        transform: translateY(-4px);
      }
      .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      .card-title {
        font-size: 1.3rem;
        font-weight: var(--heading-font-weight);
      }

      .chart-container {
        width: 100%;
        min-height: 300px;
      }

      .reset-zoom-btn {
        display: none;
        position: relative;
        background-color: var(--accent-color);
        color: #fff;
        border: none;
        border-radius: 8px;
        padding: 8px 14px;
        font-size: 0.85rem;
        font-weight: var(--heading-font-weight);
        cursor: pointer;
        box-shadow: var(--card-shadow);
        transition: background var(--transition-speed),
          transform var(--transition-speed), box-shadow var(--transition-speed);
      }
      .reset-zoom-btn:hover {
        background-color: var(--accent-hover);
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
      }
      .reset-zoom-btn:active {
        transform: scale(0.96);
      }
      .highcharts-reset-zoom {
        display: none !important;
      }

      .leaderboard {
        list-style-type: none;
        margin: 0;
        padding: 0;
      }

      .leaderboard-item {
        display: flex;
        align-items: center;
        gap: 14px;
        padding: 16px 0;
        border-bottom: 1px solid var(--border-color);
      }
      .leaderboard-item:last-child {
        border-bottom: none;
      }
      .leaderboard-rank {
        font-weight: var(--heading-font-weight);
        color: var(--accent-color);
        font-size: 1.1rem;
      }
      .leaderboard-avatar {
        width: 46px;
        height: 46px;
        border-radius: 12px;
        object-fit: cover;
        box-shadow: var(--card-shadow);
      }
      .leaderboard-info {
        flex-grow: 1;
      }
      .leaderboard-name {
        font-weight: var(--heading-font-weight);
        font-size: 1rem;
      }
      .leaderboard-username {
        font-size: 0.85rem;
        color: var(--text-muted);
      }
      .leaderboard-score {
        font-weight: var(--heading-font-weight);
        color: var(--accent-color);
        font-size: 1.05rem;
      }

      .grid {
        display: grid;
        gap: 20px;
        grid-template-columns: repeat(2, 1fr);
      }
      @media (max-width: 768px) {
        .grid {
          grid-template-columns: 1fr;
        }
        .tabs {
          flex-direction: column;
          gap: 10px;
        }
        .tab {
          width: 100%;
        }
      }
    </style>
  </head>

  <body>
    <div class="container">
      <header>
        <div class="server-info">
          <img id="server-icon" class="server-icon" src="" alt="Server Icon" />
          <h1 id="server-name">Loading...</h1>
        </div>
        <button id="exportCsvBtn">Export to CSV</button>
      </header>

      <div class="tabs">
        <div class="tab active" data-tab="overview">Server</div>
        <div class="tab" data-tab="channels">Channels</div>
        <div class="tab" data-tab="users">Users</div>
        <div class="tab" data-tab="leaderboard">Leaderboard</div>
      </div>

      <div id="overview" class="tab-content active">
        <div class="card">
          <div class="card-header">
            <h2 class="card-title">Server Overview</h2>
          </div>
          <div id="server-overview-chart" class="chart-container"></div>
        </div>
      </div>

      <div id="channels" class="tab-content">
        <div class="grid" id="channel-charts-grid"></div>
      </div>

      <div id="users" class="tab-content">
        <div class="grid" id="user-charts-grid"></div>
      </div>

      <div id="leaderboard" class="tab-content">
        <div class="card">
          <div class="card-header">
            <h2 class="card-title">User Leaderboard</h2>
          </div>
          <ul id="leaderboard-list" class="leaderboard"></ul>
        </div>
      </div>
    </div>

    <script>
      function getApiUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        const serverId = urlParams.get("server");
        if (serverId) {
          return `https://api.communitrics.com/counting/s/${serverId}/all`;
        }
        return "https://api.communitrics.com/counting/s/1150096734576451614/all";
      }

      const apiUrl = getApiUrl();
      let serverData;
      let charts = {};

      async function fetchData() {
        try {
          const response = await fetch(apiUrl);
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          return await response.json();
        } catch (error) {
          console.error("Data fetch error:", error);
          return null;
        }
      }

      function initializeDashboard() {
        fetchData().then((data) => {
          if (data) {
            serverData = data;
            updateServerInfo(() => {
              createServerOverviewChart();
              createChannelCharts();
              createUserCharts();
              createLeaderboard();
              initializeTabs();
            });
          }
        });
      }

      document.addEventListener("DOMContentLoaded", initializeDashboard);

      function extractColorFromImage(imgSrc, callback) {
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = imgSrc;
        img.onload = () => {
          const colorThief = new ColorThief();
          const palette = colorThief.getPalette(img, 8);
          const vibrant = getMostVibrantColor(palette);
          const color = `rgba(${vibrant.join(",")}, 0.6)`;
          callback(color);
        };
      }

      function getVibrancy(rgb) {
        const [r, g, b] = rgb;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const saturation = max - min;
        const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
        return saturation * brightness;
      }

      function getMostVibrantColor(palette) {
        return palette.reduce((mostVibrant, color) =>
          getVibrancy(color) > getVibrancy(mostVibrant) ? color : mostVibrant
        );
      }

      function updateServerInfo(callback) {
        const serverIcon = document.getElementById("server-icon");
        const serverName = document.getElementById("server-name");
        serverName.textContent = serverData.server_name;
        serverIcon.src = serverData.server_image;

        serverIcon.onload = () => {
          extractColorFromImage(serverData.server_image, (color) => {
            document.documentElement.style.setProperty("--accent-color", color);
            callback();
          });
        };
      }

      function initializeTabs() {
        const tabs = document.querySelectorAll(".tab");
        const tabContents = document.querySelectorAll(".tab-content");

        tabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            const tabId = tab.getAttribute("data-tab");
            tabs.forEach((t) => t.classList.remove("active"));
            tabContents.forEach((content) =>
              content.classList.remove("active")
            );
            tab.classList.add("active");
            document.getElementById(tabId).classList.add("active");
          });
        });
      }

      function createServerOverviewChart() {
        const container = document.getElementById("server-overview-chart");
        container.style.height = "500px";

        const resetButton = document.createElement("button");
        resetButton.textContent = "Reset Zoom";
        resetButton.className = "reset-zoom-btn";
        const cardHeader = document.querySelector("#overview .card-header");
        cardHeader.appendChild(resetButton);

        const allCounts = serverData.channels.flatMap((channel) =>
          channel.counts.map((count) => ({
            ...count,
            channelName: channel.channel_name,
          }))
        );
        allCounts.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        let cumulativeCount = 0;
        const cumulativeData = allCounts.map((count) => {
          cumulativeCount += 1;
          return [
            new Date(count.timestamp).getTime(),
            cumulativeCount,
            count.channelName,
          ];
        });

        const totalPoints = cumulativeData.length;
        let skipRate = 1;
        if (totalPoints > 2000) {
          skipRate = Math.ceil(totalPoints / 2000);
        }
        const sampledData = cumulativeData.filter(
          (_, index) => index % skipRate === 0
        );

        charts["server-overview"] = Highcharts.chart(container, {
          chart: {
            type: "area",
            zoomType: "x",
            backgroundColor: "transparent",
            height: 500,
            animation: true,
            resetZoomButton: {
              theme: { display: "none" },
            },
            style: {
              fontFamily: "Poppins, sans-serif",
            },
            events: {
              selection: function (event) {
                if (event.xAxis) {
                  resetButton.style.display = "inline-block";
                }
              },
            },
          },
          title: { text: null },
          xAxis: {
            type: "datetime",
            tickAmount: 6,
            labels: {
              style: {
                color: getComputedStyle(
                  document.documentElement
                ).getPropertyValue("--text-color"),
                fontSize: "12px",
              },
              formatter: function () {
                const date = Highcharts.dateFormat("%b %d, %Y", this.value);
                const time = Highcharts.dateFormat("%H:%M:%S", this.value);
                return `${date}\n${time}`;
              },
            },
            lineColor: getComputedStyle(
              document.documentElement
            ).getPropertyValue("--border-color"),
            tickColor: getComputedStyle(
              document.documentElement
            ).getPropertyValue("--border-color"),
          },
          yAxis: {
            title: { text: null },
            labels: {
              style: {
                color: getComputedStyle(
                  document.documentElement
                ).getPropertyValue("--text-color"),
                fontSize: "12px",
              },
            },
            gridLineColor: getComputedStyle(
              document.documentElement
            ).getPropertyValue("--border-color"),
          },
          tooltip: {
            backgroundColor: "#333333",
            style: {
              color: "#ffffff",
              fontWeight: "normal",
              fontSize: "12px",
            },
            formatter: function () {
              return (
                "<b>Date:</b> " +
                Highcharts.dateFormat("%b %d, %Y, %H:%M:%S", this.x) +
                "<br/><b>Total counts:</b> " +
                this.y.toLocaleString()
              );
            },
            useHTML: true,
            borderRadius: 8,
            borderWidth: 0,
          },
          series: [
            {
              name: "Total Counts",
              data: sampledData.map((d) => ({
                x: d[0],
                y: d[1],
                channel: d[2],
              })),
              color: getComputedStyle(
                document.documentElement
              ).getPropertyValue("--accent-color"),
              fillColor: getComputedStyle(
                document.documentElement
              ).getPropertyValue("--accent-color"),
              marker: { enabled: false },
            },
          ],
          plotOptions: {
            area: {
              lineWidth: 2,
              fillOpacity: 0.5,
            },
            series: {
              states: {
                hover: {
                  lineWidth: 2,
                },
              },
            },
          },
          credits: { enabled: false },
          exporting: { enabled: false },
          legend: { enabled: false },
        });

        resetButton.addEventListener("click", () => {
          charts["server-overview"].zoomOut();
          resetButton.style.display = "none";
        });
      }

      function createChannelCharts() {
        const channelChartsGrid = document.getElementById(
          "channel-charts-grid"
        );

        if (serverData.channels.length > 1) {
          channelChartsGrid.classList.add("grid");
        } else {
          channelChartsGrid.classList.remove("grid");
        }

        serverData.channels.forEach((channel) => {
          const card = document.createElement("div");
          card.className = "card";
          card.innerHTML = `
            <div class="card-header">
              <h2 class="card-title">${channel.channel_name}</h2>
              <button id="resetZoomChannel-${channel.channel_id}" class="reset-zoom-btn">Reset Zoom</button>
            </div>
            <div id="channel-${channel.channel_id}-chart" class="chart-container"></div>
          `;
          channelChartsGrid.appendChild(card);

          const container = document.getElementById(
            `channel-${channel.channel_id}-chart`
          );
          container.style.height =
            serverData.channels.length > 1 ? "320px" : "500px";
          const resetButton = document.getElementById(
            `resetZoomChannel-${channel.channel_id}`
          );

          const accentColor = getComputedStyle(
            document.documentElement
          ).getPropertyValue("--accent-color");
          const channelCounts = channel.counts.map((count) => [
            new Date(count.timestamp).getTime(),
            count.count_number,
          ]);
          channelCounts.sort((a, b) => a[0] - b[0]);

          const totalPoints = channelCounts.length;
          let skipRate = 1;
          if (totalPoints > 2000) {
            skipRate = Math.ceil(totalPoints / 2000);
          }
          const sampledData = channelCounts.filter(
            (_, index) => index % skipRate === 0
          );

          charts[`channel-${channel.channel_id}`] = Highcharts.chart(
            container,
            {
              chart: {
                type: "area",
                zoomType: "x",
                backgroundColor: "transparent",
                animation: true,
                resetZoomButton: { theme: { display: "none" } },
                style: { fontFamily: "Poppins, sans-serif" },
                events: {
                  selection: function (event) {
                    if (event.xAxis) {
                      resetButton.style.display = "inline-block";
                    }
                  },
                },
              },
              title: { text: null },
              xAxis: {
                type: "datetime",
                tickAmount: 6,
                labels: {
                  style: {
                    color: getComputedStyle(
                      document.documentElement
                    ).getPropertyValue("--text-color"),
                    fontSize: "12px",
                  },
                  formatter: function () {
                    const date = Highcharts.dateFormat("%b %d, %Y", this.value);
                    const time = Highcharts.dateFormat("%H:%M:%S", this.value);
                    return `${date}\n${time}`;
                  },
                },
                lineColor: getComputedStyle(
                  document.documentElement
                ).getPropertyValue("--border-color"),
                tickColor: getComputedStyle(
                  document.documentElement
                ).getPropertyValue("--border-color"),
              },
              yAxis: {
                title: { text: null },
                labels: {
                  style: {
                    color: getComputedStyle(
                      document.documentElement
                    ).getPropertyValue("--text-color"),
                    fontSize: "12px",
                  },
                },
                gridLineColor: getComputedStyle(
                  document.documentElement
                ).getPropertyValue("--border-color"),
              },
              tooltip: {
                backgroundColor: "#333333",
                style: {
                  color: "#ffffff",
                  fontSize: "12px",
                },
                formatter: function () {
                  return (
                    "<b>Date:</b> " +
                    Highcharts.dateFormat("%b %d, %Y, %H:%M:%S", this.x) +
                    "<br/><b>Count:</b> " +
                    this.y.toLocaleString()
                  );
                },
                useHTML: true,
                borderRadius: 8,
                borderWidth: 0,
              },
              series: [
                {
                  name: "Count",
                  data: sampledData,
                  color: accentColor,
                  fillColor: accentColor,
                  marker: { enabled: false },
                },
              ],
              plotOptions: {
                area: {
                  lineWidth: 2,
                  lineColor: accentColor,
                  fillOpacity: 0.5,
                },
                series: {
                  states: {
                    hover: {
                      lineWidth: 2,
                    },
                  },
                },
              },
              credits: { enabled: false },
              exporting: { enabled: false },
              legend: { enabled: false },
            }
          );

          resetButton.addEventListener("click", () => {
            charts[`channel-${channel.channel_id}`].zoomOut();
            resetButton.style.display = "none";
          });
        });
      }

      function createUserCharts() {
        const userChartsGrid = document.getElementById("user-charts-grid");
        const userCounts = {};
        const userTotals = {};

        const allCounts = serverData.channels.flatMap((channel) =>
          channel.counts.map((count) => ({
            ...count,
            channelName: channel.channel_name,
          }))
        );
        allCounts.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        allCounts.forEach((count) => {
          if (!userCounts[count.user_id]) {
            userCounts[count.user_id] = {
              id: count.user_id,
              username: count.username,
              display_name: count.display_name,
              profile_pic: count.profile_pic,
              counts: [],
            };
          }
          userCounts[count.user_id].counts.push({
            x: new Date(count.timestamp).getTime(),
            y: userCounts[count.user_id].counts.length + 1,
          });

          if (!userTotals[count.user_id]) {
            userTotals[count.user_id] = { id: count.user_id, total: 0 };
          }
          userTotals[count.user_id].total += 1;
        });

        const sortedUsers = Object.values(userTotals).sort(
          (a, b) => b.total - a.total
        );

        if (Object.keys(userCounts).length > 1) {
          userChartsGrid.classList.add("grid");
        } else {
          userChartsGrid.classList.remove("grid");
        }

        sortedUsers.forEach((userTotal, index) => {
          const user = userCounts[userTotal.id];
          const rank = index + 1;

          const card = document.createElement("div");
          card.className = "card";
          card.innerHTML = `
            <div class="card-header">
              <div style="display: flex; align-items: center; gap: 12px;">
                <img
                  src="${user.profile_pic}"
                  alt="${user.display_name}'s Profile Picture"
                  style="
                    width: 46px;
                    height: 46px;
                    border-radius: 12px;
                    object-fit: cover;
                    box-shadow: var(--card-shadow);
                  "
                />
                <div>
                  <h2 class="card-title" style="margin: 0;">${user.display_name} (@${user.username})</h2>
                  <small style="color: var(--text-muted);">Leaderboard Rank: #${rank}</small>
                </div>
              </div>
              <button id="resetZoomUser-${user.id}" class="reset-zoom-btn">Reset Zoom</button>
            </div>
            <div id="user-${user.id}-chart" class="chart-container"></div>
          `;
          userChartsGrid.appendChild(card);

          const container = document.getElementById(`user-${user.id}-chart`);
          container.style.height =
            Object.keys(userCounts).length > 1 ? "320px" : "500px";
          const resetButton = document.getElementById(
            `resetZoomUser-${user.id}`
          );

          const profilePic = new Image();
          profilePic.crossOrigin = "Anonymous";
          profilePic.src = user.profile_pic;
          profilePic.onload = () => {
            const colorThief = new ColorThief();
            const palette = colorThief.getPalette(profilePic, 8);
            const vibrant = getMostVibrantColor(palette);
            const color = `rgba(${vibrant.join(",")}, 0.65)`;

            resetButton.style.backgroundColor = color;

            const userData = user.counts;
            const totalPoints = userData.length;
            let skipRate = 1;
            if (totalPoints > 2000) {
              skipRate = Math.ceil(totalPoints / 2000);
            }
            const sampledData = userData.filter(
              (_, idx) => idx % skipRate === 0
            );

            charts[`user-${user.id}`] = Highcharts.chart(container, {
              chart: {
                type: "area",
                zoomType: "x",
                backgroundColor: "transparent",
                animation: true,
                resetZoomButton: { theme: { display: "none" } },
                style: {
                  fontFamily: "Poppins, sans-serif",
                },
                events: {
                  selection: function (event) {
                    if (event.xAxis) {
                      resetButton.style.display = "inline-block";
                    }
                  },
                },
              },
              title: { text: null },
              xAxis: {
                type: "datetime",
                tickAmount: 6,
                labels: {
                  style: {
                    color: getComputedStyle(
                      document.documentElement
                    ).getPropertyValue("--text-color"),
                    fontSize: "12px",
                  },
                  formatter: function () {
                    const date = Highcharts.dateFormat("%b %d, %Y", this.value);
                    const time = Highcharts.dateFormat("%H:%M:%S", this.value);
                    return `${date}\n${time}`;
                  },
                },
                lineColor: getComputedStyle(
                  document.documentElement
                ).getPropertyValue("--border-color"),
                tickColor: getComputedStyle(
                  document.documentElement
                ).getPropertyValue("--border-color"),
              },
              yAxis: {
                title: { text: null },
                labels: {
                  style: {
                    color: getComputedStyle(
                      document.documentElement
                    ).getPropertyValue("--text-color"),
                    fontSize: "12px",
                  },
                },
                gridLineColor: getComputedStyle(
                  document.documentElement
                ).getPropertyValue("--border-color"),
              },
              tooltip: {
                backgroundColor: "#333333",
                style: {
                  color: "#ffffff",
                  fontSize: "12px",
                },
                formatter: function () {
                  return (
                    "<b>Date:</b> " +
                    Highcharts.dateFormat("%b %d, %Y, %H:%M:%S", this.x) +
                    "<br/><b>Total counts:</b> " +
                    this.y.toLocaleString()
                  );
                },
                useHTML: true,
                borderRadius: 8,
                borderWidth: 0,
              },
              series: [
                {
                  name: "Total Counts",
                  data: sampledData,
                  color: color,
                  fillColor: color,
                  marker: { enabled: false },
                },
              ],
              plotOptions: {
                area: {
                  lineWidth: 2,
                  lineColor: color,
                  fillOpacity: 0.5,
                },
                series: {
                  states: {
                    hover: {
                      lineWidth: 2,
                    },
                  },
                },
              },
              credits: { enabled: false },
              exporting: { enabled: false },
              legend: { enabled: false },
            });

            resetButton.addEventListener("click", () => {
              charts[`user-${user.id}`].zoomOut();
              resetButton.style.display = "none";
            });
          };
        });
      }

      function createLeaderboard() {
        const leaderboard = document.getElementById("leaderboard-list");
        const userTotals = {};

        serverData.channels.forEach((channel) => {
          channel.counts.forEach((count) => {
            if (!userTotals[count.user_id]) {
              userTotals[count.user_id] = {
                username: count.username,
                display_name: count.display_name,
                profile_pic: count.profile_pic,
                total: 0,
              };
            }
            userTotals[count.user_id].total += 1;
          });
        });

        const sortedUsers = Object.values(userTotals).sort(
          (a, b) => b.total - a.total
        );

        sortedUsers.forEach((user, index) => {
          const li = document.createElement("li");
          li.className = "leaderboard-item";
          li.innerHTML = `
            <span class="leaderboard-rank">#${index + 1}</span>
            <img
              class="leaderboard-avatar"
              src="${user.profile_pic}"
              alt="${user.display_name}"
            />
            <div class="leaderboard-info">
              <span class="leaderboard-name">${user.display_name}</span>
              <span class="leaderboard-username">@${user.username}</span>
            </div>
            <span class="leaderboard-score">${user.total.toLocaleString()}</span>
          `;
          leaderboard.appendChild(li);
        });
      }

      document
        .getElementById("exportCsvBtn")
        .addEventListener("click", async () => {
          const zip = new JSZip();

          if (!serverData) {
            serverData = await fetchData();
          }

          const mainDataFolder = zip.folder("main_data");
          const serverDataCsv = generateServerDataCsv(serverData);
          mainDataFolder.file("server_data.csv", serverDataCsv);

          serverData.channels.forEach((channel) => {
            const channelCsv = generateChannelDataCsv(channel);
            mainDataFolder.file(
              `channel_${channel.channel_name}.csv`,
              channelCsv
            );
          });

          const leaderboardCsv = generateLeaderboardCsv(serverData);
          mainDataFolder.file("leaderboard.csv", leaderboardCsv);

          const userDataFolder = zip.folder("user_data");
          const userCounts = aggregateUserCounts(serverData);
          userCounts.forEach((user) => {
            const userCsv = generateUserDataCsv(user);
            userDataFolder.file(`${user.username}.csv`, userCsv);
          });

          zip.generateAsync({ type: "blob" }).then((content) => {
            saveAs(content, "data_export.zip");
          });
        });

      function generateServerDataCsv(data) {
        const allCounts = data.channels.flatMap((channel) =>
          channel.counts.map((count) => ({
            timestamp: count.timestamp,
            channelName: channel.channel_name,
          }))
        );
        allCounts.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        let cumulativeCount = 0;
        const cumulativeData = allCounts.map((count) => {
          cumulativeCount += 1;
          return [count.timestamp, cumulativeCount];
        });

        const csvRows = [["Timestamp", "Total Count"], ...cumulativeData];
        return csvRows.map((row) => row.join(",")).join("\n");
      }

      function generateChannelDataCsv(channel) {
        const csvRows = [
          ["Timestamp", "Count"],
          ...channel.counts.map((count) => [
            count.timestamp,
            count.count_number,
          ]),
        ];
        return csvRows.map((row) => row.join(",")).join("\n");
      }

      function generateLeaderboardCsv(data) {
        const userTotals = {};
        data.channels.forEach((channel) => {
          channel.counts.forEach((count) => {
            if (!userTotals[count.user_id]) {
              userTotals[count.user_id] = {
                username: count.username,
                display_name: count.display_name,
                profile_pic: count.profile_pic,
                total: 0,
              };
            }
            userTotals[count.user_id].total += 1;
          });
        });
        const sortedUsers = Object.values(userTotals).sort(
          (a, b) => b.total - a.total
        );
        const csvRows = [
          ["Rank", "Username", "Display Name", "Total Counts"],
          ...sortedUsers.map((user, index) => [
            index + 1,
            user.username,
            user.display_name,
            user.total,
          ]),
        ];
        return csvRows.map((row) => row.join(",")).join("\n");
      }

      function aggregateUserCounts(data) {
        const userCounts = {};
        data.channels.forEach((channel) => {
          channel.counts.forEach((count) => {
            if (!userCounts[count.user_id]) {
              userCounts[count.user_id] = {
                username: count.username,
                counts: [],
              };
            }
            userCounts[count.user_id].counts.push(count);
          });
        });
        return Object.values(userCounts);
      }

      function generateUserDataCsv(user) {
        const csvRows = [
          ["Timestamp", "Count"],
          ...user.counts.map((count) => [count.timestamp, count.count_number]),
        ];
        return csvRows.map((row) => row.join(",")).join("\n");
      }
    </script>
  </body>
</html>
